<!DOCTYPE html>
<html lang = "de">
    <head>
        <meta charset="utf-8">
        <title>Signatur Demo</title>
    </head>
    <body>
        <h1>Signaturvisualisierung – Online Hilfe</h1>
        <p>
		Willkommen in der Online Hilfe des Plug-Ins zur Signaturvisualisierung.
		Nachfolgenden finden Sie einen Überblick des Plug-Ins sowie eine detaillierte Erklärung zu jeden Schritt des Signaturerstellungsprozesses.
        <br>
		Die Visualisierung soll die Erzeugung einer Signatur für ein bestimmtes Dokument zeigen.
		Eine digitale Signatur kann zur Authentisierung der Identität des Senders oder des Unterzeichners des Dokuments genutzt werden. 
		Sie sichert außerdem die Integrität des Dokumentes selbst.
		</p>
		<img src="MainStart.png">
        <h2>Allgemeine Informationen</h2>
        <h3>Reset-Funktion</h3>
		<p>Die ausgewählten Hash- und Signaturfunktionen werden gespeichert, alle anderen vorgenommenen Änderungen oder Einstellungen werden auf den Ausgangszustand zurückgesetzt.</p>
		<h3>Neustart</h3>
		<p>Alle vorgenommenen Änderungen oder Einstellungen sowie die ausgewählten Hash- und Signaturfunktionen werden auf den Ausgangszustand zurückgesetzt.</p>
              
        <h2>Schritt 1 – Input auswählen</h2>
        <p>Um den Signaturerstellungsprozess zu starten, klicken Sie den Button "Input auswählen". Wählen Sie eine bereits vorhandene Datei oder geben Sie selbst einen Text ein. Wollen Sie eine bereits vorhandene Datei signieren, können Sie einen beliebigen Dateitypen wählen, die maximale Dateigröße beträgt allerdings 10 MB.</p>
      	<img src="InputWizard.png"> 
      	<img src="InputFile.png">
      	<img src="InputText.png">
        
        <h2>Schritt 2 – Hashfunktion auswählen</h2>
        <p>Der zweite Schritt des Signaturerstellungsprozesses ist die Berechnung des Hashwertes des Dokumentes. Eine Hashfunktion ist ein Algorithmus oder eine Subroutine, die einen Datensatz variabler Länge auf einen Datensatz fixer Länge abbildet. Da die Größe des Hashwertes einer Datei normalerweise viel kleiner ist als die Datei selbst, wird direkt der Hashwert signiert. Dadurch wird die Effizient des Signaturerzeugungsprozesses gesteigert. Bei der Signaturerstellung sowie bei der Verifikation der Signatur muss der gleich Hashalgorithmus verwendet werden.</p>
        <img src="HashWizard.png">
        <h3>Beschreibung der unterstützten Hashfunktionen</h3>
        <h4>MD5</h4>
        <p>Der MD5-Algoritmus (veröffentlicht im Jahr 1992 und spezifiziert in RFC 1321) generiert aus einer gegebenen Nachricht einen 128-Bit langen "Fingerabdruck" oder "Hashwert". Der MD5-Algoritmus ist für digitale Signaturapplikationen vorgesehen, in der sehr große Dateien sicher "komprimiert" werden müssen, bevor sie, wie beispielsweise in einem Public-Key-Kryptosystem wie RSA, mit einem privaten Schlüssel verschlüsselt werden. </p>
        <h4>SHA-1</h4> 
        <p>Der “Secure Hash Algoritm” (veröffentlicht im Jahr 1995 von der United States NIST) berechnet eine verkürzte Darstellung einer Nachricht oder einer Datei. SHA-1 generiert dabei aus einer Datei beliebige Länge (< 264 Bits), eine 160-Bit-Ausgabe. SHA-1 gilt als sicher, weil es praktisch unmöglich ist, eine Nachricht zu finden, die zu einem gegebenen Hashwert passt oder zwei verschiedene Nachrichten zu finden, die denselben Hashwert generieren. Jede Änderung der Nachricht hat, mit hoher Wahrscheinlichkeit, zu folge, dass der Hashwert sich ebenfalls ändert und die Verifikation der Signatur wäre nicht mehr möglich.</p>
        <h4>SHA-256</h4>
        <p>SHA-256 ist eine Nachfolger der SHA-1-Hashfunktion (allgemein auch als SHA-2 bezeichnet) und einer der stärksten zurzeit verfügbaren Hashfunktionen. Während SHA-1 praktisch noch nicht gebrochen wurde (in der Theorie allerdings schon), ist der SHA-256-Algorithum im Vergleich wesentlich komplexer. Es wird allgemein empfohlen diesen Algorithmus zu wählen, als SHA-1.</p>
        <h4>SHA-384</h4>
        <p>SHA-384 ist gleich wie SHA-512, sie unterscheiden sich allerdings in der Länge des generierten Hashwertes (SHA-384 ist verkürzt). Der initiale Hash berechnet sich aus den 64 dezimalen Bits der Quadratwurzel der aufeinanderfolgenden Primzahlen (23, 29, etc.). Zum Schluss werden nur die ersten sechs 64-Bit-Wörter aus dem Ergebnis verwendet. Die angefügte Nummer gibt die Länge der einzelnen Hashwerte (in Bits) an.</p>
        <h4>SHA-512</h4>
        <p>SHA-256 und SHA-512 unterscheiden sich in der Wortlänge. SHA-256 verwendet 32-Bit-Wörter, wobei SHA-512 64-Bit-Wörter verwendet. Die angefügte Nummer gibt die Länge der einzelnen Hashwerte (in Bits) an.</p>
        
        <h2>Schritt  3 – Signaturfunktion auswählen</h2>
        <p>Um den von Ihnen gewählten Input zu signieren, können Sie zwischen verschieden Signaturfunktionen auswählen. Einige Signaturverfahren basieren auf asymmetrischer Verschlüsselung, wie beispielsweise RSA, andere Verfahren wurden eigens für diesen Zweck entwickelt, wie DSA.</p>
        <img src="SignatureWizard.png">
        <p>Um eine Signatur zu erstellen und anschließend zu verifizieren, benötigt man zwei verschiedene Schlüssel. Der private Schlüssel wird für die Erstellung der Signatur genutzt. Nur der Besitzer des Schlüssels kennt ihn und muss ihn geheim halten. Der öffentliche Schlüssel kann von jedem verwendet werden, um die Signatur zu verifizieren. <br> Um die Signatur zu erzeugen, müssen Sie einen Schlüssel wählen, die vom Standard-JCT-Keystore zu Verfügung gestellt werden.</p>
        <a href="https://github.com/jcryptool/core/tree/master/org.jcryptool.crypto.keystore">Besuchen Sie den Standard-JCT-Keystore</a> 
        <h3>Beschreibung der unterstützten Signaturfunktionen</h3>
        <h4>DSA</h4>
        <p>Der “Digital Signature Algorithm“ (DSA) (veröffentlicht im Jahr 1991 von NIST) ist ein „United States Federal Government“-Standard für digitale Signaturen. Mit DSA ist die Entropie, Geheimhaltung, und die Einzigartigkeit des zufälligen Signatur-Wertes entscheidend. Jede Verletzung einer dieser drei Anforderungen kann dazu führen, dass der gesamte private Schlüssel dem Angreifer  offenbart wird. Wird der zufällige Signatur-Wert ein zweites Mal verwendet, ein vorhersehbarer Wert berechnet oder sind nur einige Bits des Wertes in jeder der Signaturwerte undicht, kann DAS gebrochen werden.</p>
        <p>Lernen Sie mehr über DSA: <a href="https://github.com/jcryptool/crypto/tree/master/org.jcryptool.visual.dsa">Besuchen Sie JCT-DSA</a></p> 
        <h4>RSA</h4>
        <p>RSA (veröffentlicht im Jahr 1977) ist ein Algorithmus für asymmetrische kryptographische Verfahren, die auf der mutmaßlichen Schwierigkeit der Faktorisierung von großen Zahlen, dem Faktorisierungsproblem, basiert. Jeder kann den öffentlichen Schlüssel zum Verifizieren einer Nachricht verwenden, aber nur der Besitzer des privaten Schlüssels kann die Nachricht signieren. Ein Angreifer, der den privaten Schlüssel nicht kennt, müsste den Modulus im öffentlichen Schlüssel faktorisieren. Sichere Padding-Verfahren, wie beispielsweise RSA-PSS, sind für die Sicherheit der Signaturerstellung genauso notwendig wie für die Sicherheit bei der Verschlüsselung einer Nachricht. Der Cryptography Standard PKCS #1 definiert die Empfehlungen für die Implementierung asymmetrischer Kryptografie, die auf dem RSA-Algorithmus basieren.</p>
        <p> Lernen Sie mehr über RSA: <a href="https://github.com/jcryptool/crypto/tree/master/org.jcryptool.visual.rsa">Besuchen Sie JCT-RSA</a></p> 
        <h4>ECDSA</h4>
        <p>Der “Elliptic Curve Digital Signature Algorithm” (ECDSA) (vorgeschlagen von Scott Vanstone im Jahr 1992) ist die elliptische Kurve analog dem “Digital Signature Algorithm“ (DSA). Im Gegensatz zum normalen diskreten Logarithmusproblem und dem Faktorisierungsproblem, sind für Elliptischen Kurven keine Probleme bekannt. Die Länge des privaten Schlüssels, der als sicher betrachtet wird, ist mit ECDSA wesentlich kürzer. Bei einem Sicherheitsniveau von 80 Bits, was bedeutet, ein Angreifer würde 2^80 Signaturerzeugungsprozesse benötigen um den privaten Schlüssel zu finden, ist die Größe eines öffentlichen DAS-Schlüssels mindestens 1024 Bit, während die Größe eines öffentlichen ECDA-Schlüssels 160 Bit wäre. </p>
        <h4>RSA und MGF1</h4>
        <p>MGFs (mask generation functions) verwenden eine Oktal-Zeichenkette einer variablen Länge und generieren eine Zeichenkette (ebenfalls oktal) gewünschter Länge. MGFs sind deterministisch, das heißt dass die Input-Zeichenkette die Output-Zeichenkette bestimmt. Das Ergebnis einer MGF soll pseudozufällig (das heißt unmöglich vorhersagbar) sein. Deshalb werden oft Hashfunktionen verwendet um MGFs zu implementieren. MGF1 ist im PKCS #1 v2.1 (Public-Key Cryptography Standards, publiziert von RSA Laboratories) spezifiziert.</p>
        <p> Lernen Sie mehr über RSA und MGF1: <a href="http://software.intel.com/sites/products/documentation/doclib/ipp_sa/71/ippcp/ippcp_ch3/ch3_mask_generation_functions.htm">Mask Generation Functions</a></p>
        <h3>Mehr Informationen zur Kryptografie-Bibliothek BouncyCastle:</h3>
       	<ul>
        	<li><a href="http://www.bouncycastle.org/">Besuchen Sie BouncyCastle</a></li>
        	<li><a href="https://github.com/jcryptool/core/tree/04fbe0efa19be7fee686b9fd4dcf3ee33b8e12d2/org.bouncycastle">Besuchen Sie BouncyCastle auf github</a></li>
        	<li><a href="http://www.mobilefish.com/developer/bouncycastle/bouncycastle.html">Beispiele mit BouncyCastle</a></li>
  		</ul>
        <br>
        <img src="MainFinished.png">
        <h2>Schritt 4 – Erzeugte Signatur anzeigen</h2>
        <p>Um die erzeugte Signatur anzuzeigen, klicken Sie auf den Button „Erzeugte Signatur anzeigen“. Dort finden Sie alle relevanten Informationen zu der Signatur:</p>
        <ul>
            <li>Der Benutzer, der die Signatur erstellt hat,</li>
            <li>allgemeine Informationen zum verwendeten Schlüssel, </li>
            <li>Informationen zu der Signaturfunktion,</li>
            <li>die hexadezimale, oktale oder die binäre Darstellung der signierten Datei sowie der erzeugten Signatur.</li>
        </ul>
        <p>Um die signierte Datei mit der Signatur anzuzeigen, klicken Sie auf "Speichern" und öffnen Sie die gespeicherte Datei mit dem JCT-HexEditor. Die gespeicherte Datei benötigen Sie, falls Sie Ihre Signatur prüfen möchten.</p>
		<img src="ShowSigWizard.png">

    </body>
</html>
